# Redis部署模式

> 1. 主从
>
>    通过持久化，Redis保证了即使在服务器重启的情况下也不会损失数据。避免了单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上。 
>
> 2. 哨兵
>
>    当主数据库遇到异常中断时，开发者可以通过手动的方式选择一个从数据库升级为主数据库。
>    哨兵的作用是监控redis主从数据库是否正常运行，主数据库出现故障时，自动将从数据库转换为主数据库。
>
> 3. 集群
>
>    即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储，即每台redis存储不同的内容。

# 数据更新策略
> 1. Cache Aside Pattern
>
>    失效：应用程序从cache中取数据，没有得到，从数据库中取数据，成功后，放到缓存中。
>    命中：从cache中取数据，取到后返回。
>    更新：先更新数据库，成功后，再让缓存失效。
>
> 2. Read/Write Through Pattern
>
>    对于第一种方案来说，我们应用代码都需要维护两个数据存储，一个是缓存cache，一个是数据库，而Read/Write Through 是把更新数据库的操作由缓存自己代理了
>
>    Read Through  在查询中更新缓存
>    Write Through 在更新数据库发生，先更新缓存，由cache自己去更新数据库，没有命中缓存，直接更新数据库。
>
> 3. Write Behind Caching Pattern
>
>    Write back： Linux文件系统的Page Cache算法
>     在更新数据库时，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处是让数据库的I/O操作飞快无比；因为异步，write back还可以合并对同一个数据库的多次操作。
>     缺点：数据不是强一致性。

# 持久化

> 1. Snapshotting （快照）
>
>    默认持久化方式是快照方式，将内存中的数据以快照方式写到二进制文件中，文件名默认是dump.rdb
>
>    可以配置redis在n秒内超过m个key被修改就自动做快照
>
> - save 900 1 #900 秒内如果超过 1 个 key 被修改，则发起快照保存
>
> - save 300 10 #300 秒内容如超过 10 个 key 被修改，则发起快照保存
>
>   快照保存过程
>
>   1. redis调用fork，有了父子进程
>   2. 父进程继续处理client请求，子进程将内容写到临时文件。
>   3. 子进程将快照写到临时文件完毕后，临时文件替换原来的快照文件，子进程退出。

> 2. AOF方式
>
>    ​	快照方式保存数据时有一定的间隔时间，如果redis意外down机，会丢失掉一些数据，AOF则不会有这个问题。
>
>    ​	redis会将每个收到的写命令都会通过write函数追加到文件中。当redis重启时会重新执行文件保存的写命令来重建内存数据，由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。
>
>    可以配置持久化方式来避免：
>
> - appendonly yes //启用 aof 持久化方式
> - appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化
> - appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中
> - appendfsync no //完全依赖 os，性能最好,持久化没保证
>
> aof 导致持久化文件越来越大的问题：
>
> 可以通过brrewriteaof命令压缩持久化文件，收到这个命令后，redis将使用与快照类似的方式，将内存数据以命令的方式保存到临时文件中，最后替换原来的文件

# Redis的内存淘汰

> **Redis处理内存使用完时：**
>
> ​	noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
>
> ​	allkeys-lru：从所有key中使用LRU算法进行淘汰
>
> ​	volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰
>
> ​	allkeys-random：从所有key中随机淘汰数据
>
> ​	volatile-random：从设置了过期时间的key中随机淘汰
>
> ​	volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰
>
> ​	当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误

> LRU(Least Recently Used)，即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。

> Redis3.0对近似LRU的优化
>
> Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。
>
> 当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行

# Redis为什么这么快

1. 完全基于内存

2. 数据结构简单，对数据操作也简单

3. 使用多路 I/O 复用模型

   > 多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量
   >
   > **select、poll、epoll简介**
   >
   > epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。
   >
   > 多路复用IO
   >
   > 首先，要从你常用的IO操作谈起，比如read和write，通常IO操作都是阻塞I/O的，也就是说当你调用read时，如果没有数据收到，那么线程或者进程就会被挂起，直到收到数据。
   >
   > 当服务器需要处理1000个连接的的时候，而且只有很少连接忙碌的，那么会需要1000个线程或进程来处理1000个连接，而1000个线程大部分是被阻塞起来的。由于CPU的核数或超线程数一般都不大，比如4,8,16,32,64,128，比如4个核要跑1000个线程，那么每个线程的时间槽非常短，而线程切换非常频繁。这样是有问题的：
   >
   > 1. 线程是有内存开销的，1个线程可能需要512K（或2M）存放栈，那么1000个线程就要512M（或2G）内存。
   > 2. 线程的切换，或者说上下文切换是有CPU开销的，当大量时间花在上下文切换的时候，分配给真正的操作的CPU就要少很多。
   >
   > 那么，我们就要引入**非阻塞I/O**的概念，非阻塞IO很简单，通过fcntl（POSIX）或ioctl（Unix）设为非阻塞模式，这时，当你调用read时，如果有数据收到，就返回数据，如果没有数据收到，就立刻返回一个错误，如EWOULDBLOCK。这样是不会阻塞线程了，但是你还是要不断的轮询来读取或写入。
   >
   > 于是，我们需要引入**IO多路复用**的概念。多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。
   >
   > 这样在处理1000个连接时，只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。
   
   > 先解释下笼统的IO多路复用模型
   >
   > 1. 传统的多进程并发模型：每监听到一个socket连接，就会分配一个线程处理
   >
   > 2. 多路复用模型：单个线程，通过记录跟踪每一个socket连接的IO状态，来管理多个IO流
   >
   >    （这里的IO指`网络IO`，多路指`多个网络连接`，复用指`复用一个线程`）
   >
   > 再说redis的IO多路复用模型
   >
   > 1. IO多路复用模型会监听多个客户端的socket连接
   >
   > 2. 每当有客户端向redis发出请求时，IO多路复用模型会将请求放进队列中
   >
   > 3. IO多路复用模型每次将队列中的一个任务交给处理器处理
   >
   > 4. IO多路复用模型会有序，同步的处理队列中的任务
   >
   >    ![img](./img/redis-2.png)

# Redis 问题与解决

> 缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。
>
> 缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中
>
> 缓存雪崩：就是大量数据同一时间失效。
>
> **解决办法**
>
> 缓存穿透：
>
> 1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id<=0的直接拦截；
>
> 2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-特定空值，这样可以防止攻击用户反复用同一个id暴力攻击
>
> 缓存击穿：
>
> 最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员
>
> 缓存雪崩：
>
> 1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
>
> 2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。

