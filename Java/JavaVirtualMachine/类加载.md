
# 类加载器
> 1. 启动Bootstrap类加载器
> 2. 扩展Extension类加载器
> 3. 系统System类加载器
> 4. 自定义类加载器

## 类加载的过程
> 1. 加载: 查找字节码文件，用字节码文件创建class对象
> 2. 验证：验证字节码中的信息是否符合当前虚拟机的要求，文件格式验证，元数据验证，字节码验证，符号引用验证
> 3. 准备：给类对象分配内存，设置初始值
> 4. 解析：将常量池中的符号引用替换为直接引用，对接口解析，字段解析，类方法解析。
> 5. 初始化：对该类的父类进行初始化，执行静态初始化器，初始化静态变量

# 双亲委派模式
> 一个类加载器收到了类加载请求，并不会自己先加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，如果父类加载器可以完成加载任务，则直接返回，若无法加载，则子加载器才会尝试加载。

## 双亲委派模式的作用
> 1. 共享功能： 一些framework层级的类一旦被顶层加载器加载，缓存在内存中。在其他任何地方用到时，都遵守双亲加载机制，派发到顶层加载器，因已经加载，所以都不需要加载。
>
> 2. 隔离功能，保证核心类库的纯净和安全，防止恶意加载。（例如：核心类库都有顶层类加载器加载，不会再去加载用户自定义伪装的核心类）
>
> 3. 双亲委派机制在很大程度上防止内存中出现多个相同的字节码文件，加载类的时候会默认使用当前类的ClassLoader进行加载，只有当你使用该class的时候才会去装载，一个类加载器只会装载同一个class一次。可以通过A.class.getClassLoader查看当前A类的类加载器。

# 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式
> 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，有各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。
> 双亲委派模型的实现很简单，实现代码都集中在java.lang.ClassLoader的loadClass()方法之中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

---
## 破坏双亲委派模式的场景：
> 1. JDK1.2之前还没有引入双亲委派模式，为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。
> 2. JNDI服务的代码有启动类加载器去加载，但JNDI的目的就是对资源进行集中管理和查找，它需要调用有独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，单启动类加载器不可能“认识”这些代码。为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这个行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都是采用这种方式，例如：JNDI、JDBC、JCE、JAXB、和JBI等。


# 类的实例化顺序
> 1. 父类的静态变量和静态代码块（看两者的书写顺序）；
> 2. 子类的静态变量和静态代码块（看两者的书写顺序）；
> 3. 父类的成员变量赋值
> 4. 父类类的构造代码块
> 5. 父类的构造方法（）
> 6. 执行子类的构造代码块
> 7. 子类的构造方法（）
>
> **先是父类，再是子类； 
> 先是类静态变量和静态代码块，再是对象的成员变量和构造代码块–》构造方法。**

