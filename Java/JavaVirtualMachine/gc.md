# 对象已死？
	**可达性分析算法**
    从GCRoots作为对象的起始点，向下搜索，当一个对象到GCRoots没有任务引用链相连时，
    则该对象可回收。

# Java内存模型
	1. 程序计数器：当前线程所执行的字节码的行号指示器
	2. 栈区：基本数据类型，对象的引用
	3. 堆区：对象实例，数组，（所有线程共享）
	4. 方法区：类信息，常量，静态变量

# 垃圾回收算法
## 1. 标记-清除算法
	a. 标记出所有需要回收的对象
    b. 回收被标记的对象
    缺点：
    a. 标记和清除过程效率都不高
    b. 会产生大量不连续的内存碎片
## 2. 复制算法
	a. 将可用内存按容量划分为大小相等的两块，每次使用一块
    b. 将还存活的对象复制到另一块上面
    缺点：内存缩小为一半
## 3. 标记-整理算法
	a. 标记出所有需要回收的对象
    b. 把所有存活的对象向一端移动
## 4. 分代收集算法
	a. 将对象分为新生代，老生代
    b. 新生代在每次回收时都有大量对象死去，只有少量存活，用复制算法，只需要复制少量对象就可以完成收集。老生代，对象存活率高，用标记清除或标记整理算法。

# 类加载器
	1. 启动Bootstrap类加载器
	2. 扩展Extension类加载器
	3. 系统System类加载器
	4. 自定义类加载器
## 类加载的过程
	1. 加载: 查找字节码文件，用字节码文件创建class对象
	2. 验证：验证字节码中的信息是否符合当前虚拟机的要求，文件格式验证，元数据验证，字节码验证，符号引用验证
	3.准备：给类对象分配内存，设置初始值
	4.解析：将常量池中的符号引用替换为直接引用，对接口解析，字段解析，类方法解析。
	5.初始化：对该类的父类进行初始化，执行静态初始化器，初始化静态变量
# 双亲委派模式
	一个类加载器收到了类加载请求，并不会自己先加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，如果父类加载器可以完成加载任务，则直接返回，若无法加载，则子加载器才会尝试加载。
## 双亲委派模式的作用
	1. 共享功能： 一些framework层级的类一旦被顶层加载器加载，缓存在内存中。在其他任何地方用到时，都遵守双亲加载机制，派发到顶层加载器，因已经加载，所以都不需要加载。
	
	2. 隔离功能，保证核心类库的纯净和安全，防止恶意加载。（例如：核心类库都有顶层类加载器加载，不会再去加载用户自定义伪装的核心类）
	
	3. 双亲委派机制在很大程度上防止内存中出现多个相同的字节码文件，加载类的时候会默认使用当前类的ClassLoader进行加载，只有当你使用该class的时候才会去装载，一个类加载器只会装载同一个class一次。可以通过A.class.getClassLoader查看当前A类的类加载器。