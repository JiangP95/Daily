**类加载过程：**

> 1. 加载
>
>    查找和导入class文件
>
> 2. 链接：把类的二进制数据合并到JRE中
>
>    a. 校验：检测载入的class文件数据的正确性
>    b. 准备： 给类的静态变量分配储存空间
>    c. 解析： 将符号引用转为直接引用
>
> 3. 初始化：对类的静态变量，静态代码块执行初始化操作
>
> 4. 卸载

**Java程序的动态扩展：**

>  可以由运行期动态加载和动态链接实现。比如说 多态，在运行时再指定其实际的实现，解析过程有可能在初始化之后执行。
>
> 上诉的过程，加载，校验，准备，初始化，卸载这个五个阶段的顺序是确定的，但是解析阶段不一定，某些情况下可以在初始化阶段后执行。类的生命周期的每一个阶段都是互相交叉混合式进行的，通常会在一个阶段执行过程中调用或激活另一个过程。

**初始化过程：**

> 在类加载的准备阶段，已经对类变量进行初始化了，这里的初始化是执行类构造器
>
> a. 父类静态变量初始化
>
> b. 子类静态变量初始化
>
> 1. 父类非静态变量初始化，赋值
>
> 2. 父类构造函数执行
>
> 3. 子类非静态变量初始化，赋值
>
> 4. 子类构造函数执行
>
> 5. 实例化完成

**初始化触发条件：**

> 主动引用
>
> 1. new（实例化对象）、getstatic（获取类变量的值，被final修饰的除外，他的值在编译器时放到了常量池）、putstatic（给类变量赋值）、invokestatic（调用静态方法）
>
> 2. 使用java.lang.reflect包的方法对类进行反射调用方法
>
> 3. 初始化类的时候，如果他的父类还没有初始化，要先初始化父类
>
> 4. 虚拟机启动时，含有main方法的类，会被先初始化
>
> 被动引用
>
> 1. 在第三方类中，使用子类引用父类的类变量，不会初始化子类
>
> 2. 在第三方类中，通过数组定义来应用类，不会初始化类
>
> 3. 在第三方类中，引用类的常类变量（同时被final和static修饰的变量），不会触发类的初始化（因为在第三方类的编译之后，常量就被放在第三方类的常量池中了）